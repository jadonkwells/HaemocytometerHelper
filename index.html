<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Haemocytometer Helper v1.1</title>

  <!-- External libraries for Excel export with screenshots -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/exceljs/4.4.0/exceljs.min.js"></script>

  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      min-height: 100vh;
      padding: 20px;
    }

    .app-header {
      text-align: center;
      color: white;
      margin-bottom: 30px;
      padding: 20px;
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(10px);
      border-radius: 20px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
    }

    .app-header h1 {
      font-size: 2.5rem;
      font-weight: 700;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.2);
      margin-bottom: 10px;
    }

    .app-header p {
      font-size: 1.1rem;
      opacity: 0.95;
    }

    .app-header .version-label {
      font-size: 0.9rem;
      opacity: 0.8;
      margin-bottom: 5px;
      font-weight: 500;
    }

    .container {
      max-width: 1400px;
      margin: 0 auto;
    }

    .grid-layout {
      /* Always stack cards vertically so each sits on its own row rather than side‚Äëby‚Äëside.
         This prevents mismatched heights and blank space when cards have different amounts
         of content. The gap property controls vertical spacing between cards, and
         margin-top creates space between the top mode card and the first card in the grid. */
      display: grid;
      grid-template-columns: 1fr;
      gap: 20px;
      margin-top: 20px;
      margin-bottom: 20px;
    }

    .card {
      background: white;
      border-radius: 20px;
      padding: 25px;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.15);
      transition: transform 0.3s ease, box-shadow 0.3s ease;
      position: relative;
      overflow: hidden;
      /* Limit card width to mimic a mobile form factor on larger screens. Center cards horizontally */
      width: 100%;
      max-width: 550px;
      margin-left: auto;
      margin-right: auto;
    }

    /* Disable translate on hover for cards so they don't shift position when moused over.
       We keep the hover shadow effect for subtle feedback without moving the container. */
    .card:hover {
      /* Remove vertical movement on hover */
      transform: none;
      box-shadow: 0 15px 50px rgba(0, 0, 0, 0.2);
    }

    .card::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 4px;
      background: linear-gradient(90deg, #667eea, #764ba2);
    }

    .card-title {
      font-size: 1.4rem;
      font-weight: 600;
      margin-bottom: 20px;
      color: #2d3748;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .card-icon {
      width: 30px;
      height: 30px;
      background: linear-gradient(135deg, #667eea, #764ba2);
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-weight: bold;
    }

    /* Mode selection card special styling */
    .mode-card {
      background: linear-gradient(135deg, #ffeaa7 0%, #fdcb6e 100%);
    }

    /* Haemocytometer card - Trypan Blue theme */
    .haemo-card {
      background: linear-gradient(135deg, #dfe6e9 0%, #b2bec3 100%);
    }

    .haemo-card::before {
      background: linear-gradient(90deg, #0984e3, #74b9ff);
    }

    /* Cell culture media pink theme for seeding */
    .seeding-card {
      background: linear-gradient(135deg, #ffeef8 0%, #ffd4e8 100%);
    }

    .seeding-card::before {
      background: linear-gradient(90deg, #ff6b9d, #feca57);
    }

    /* Freezing card - cool blue theme */
    .freezing-card {
      background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%);
    }

    .freezing-card::before {
      background: linear-gradient(90deg, #2196f3, #64b5f6);
    }

    /* Results card - success green theme */
    .results-card {
      background: linear-gradient(135deg, #e8f5e9 0%, #c8e6c9 100%);
    }

    .results-card::before {
      background: linear-gradient(90deg, #4caf50, #81c784);
    }

    /* Form styling */
    .form-group {
      margin-bottom: 18px;
    }

    .form-label {
      display: block;
      margin-bottom: 6px;
      font-weight: 500;
      color: #4a5568;
      font-size: 0.95rem;
    }

    .form-control {
      width: 100%;
      padding: 10px 14px;
      border: 2px solid #e2e8f0;
      border-radius: 12px;
      font-size: 1rem;
      transition: all 0.3s ease;
      background: white;
    }

    .form-control:focus {
      outline: 2px solid #667eea;
      outline-offset: 2px;
    }

    .form-control.invalid {
      border-color: #f56565;
      background: #fff5f5;
    }

    .form-control.readonly {
      background: #f0f0f0;
      border-style: dashed;
    }

    /* Mode toggles */
    .mode-group {
      /* Stack the mode selection inputs vertically to avoid cramped layouts when cards are
         constrained to a mobile-like width. Each child spans the full width of the parent. */
      display: flex;
      flex-direction: column;
      gap: 15px;
    }

    .mode-group > div {
      width: 100%;
    }

    /* Results styling */
    .result-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 15px;
    }

    .result-item {
      background: white;
      padding: 15px;
      border-radius: 12px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
    }

    .result-item.wide {
      grid-column: 1 / -1;
    }

    .result-label {
      font-size: 0.85rem;
      color: #718096;
      margin-bottom: 5px;
      font-weight: 500;
    }

    .result-value {
      font-size: 1.3rem;
      font-weight: 700;
      color: #2d3748;
      word-break: break-word;
      width: 100%;
      padding: 8px;
      border: 1px solid #e2e8f0;
      border-radius: 8px;
      background: #f7fafc;
    }

    /* Instruction box */
    .instruction-box {
      background: linear-gradient(135deg, #fff9c4 0%, #ffecb3 100%);
      border-left: 4px solid #ffc107;
      padding: 15px;
      border-radius: 8px;
      font-size: 1.05rem;
      line-height: 1.6;
      color: #5d4037;
      margin-top: 15px;
    }

    /* Buttons */
    .btn {
      padding: 10px 20px;
      border: none;
      border-radius: 10px;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .btn-primary {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
    }

    .btn-primary:hover {
      box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
    }

    .btn-secondary {
      background: linear-gradient(135deg, #636e72 0%, #2d3436 100%);
      color: white;
      box-shadow: 0 4px 15px rgba(45, 52, 54, 0.3);
    }

    .btn-warning {
      background: linear-gradient(135deg, #fdcb6e 0%, #e17055 100%);
      color: white;
      box-shadow: 0 4px 15px rgba(253, 203, 110, 0.3);
    }

    /* Stock concentration input with multiplier button */
    .stock-input-wrapper {
      display: flex;
      gap: 10px;
      align-items: stretch;
    }
    .stock-input-wrapper input {
      flex: 1;
    }
    .stock-input-wrapper .btn {
      white-space: nowrap;
    }

    /* Adjust spacing above the export card to separate it from preceding content. */
    #exportCard {
      margin-top: 20px;
    }

    .button-group {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      margin-top: 20px;
    }

    /* Table styling */
    .data-table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 20px;
      background: white;
      border-radius: 12px;
      overflow: hidden;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
    }

    .data-table thead {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
    }

    .data-table th {
      padding: 12px;
      text-align: left;
      font-weight: 600;
      font-size: 0.9rem;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .data-table td {
      padding: 10px 12px;
      border-top: 1px solid #e2e8f0;
      font-size: 0.95rem;
    }

    /* Hide elements initially */
    .hidden {
      display: none !important;
    }

    /* Responsive */
    @media (max-width: 768px) {
      .app-header h1 {
        font-size: 1.8rem;
      }
      
      .grid-layout {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body>
  <div class="app-header">
    <h1>üß¨ Haemocytometer Helper</h1>
    <p class="version-label">Version 1.1</p>
    <p>Professional tool for haemocytometer counting, plate seeding, and cell freezing</p>
  </div>

  <div class="container">
    <!-- Mode Selection Card -->
    <div class="card mode-card">
      <h2 class="card-title">
        <span class="card-icon">‚öôÔ∏è</span>
        Setup Your Workflow
      </h2>
      <div class="mode-group">
        <div class="form-group">
          <label class="form-label">How will you provide concentration?</label>
          <select id="measurementMode" class="form-control">
            <option value="haem">I'm using a haemocytometer</option>
            <option value="stock">I already know my stock concentration</option>
          </select>
        </div>
        <div id="countingModeDiv" class="form-group">
          <label class="form-label">Cell counting mode</label>
          <select id="countingMode" class="form-control">
            <option value="total" selected>Total cell count only</option>
            <option value="liveDead">Live + Dead counts (viability)</option>
          </select>
        </div>
        <div class="form-group">
          <label class="form-label">What are you doing today?</label>
          <select id="purposeMode" class="form-control">
            <option value="seeding">Seeding plates</option>
            <option value="freezing">Freezing down vials</option>
          </select>
        </div>
      </div>
    </div>

    <div class="grid-layout">
      <!-- Haemocytometer Card -->
      <div id="haemoCard" class="card haemo-card">
        <h2 class="card-title">
          <span class="card-icon">üî¨</span>
          Haemocytometer Count
        </h2>
        
        <div id="haemoFields">
          <!-- Total count mode (default) -->
          <div id="totalCountDiv" class="form-group">
            <label class="form-label">Total Cell Count</label>
            <input id="totalCount" type="number" min="0" class="form-control" placeholder="Enter your count">
          </div>

          <!-- Live + Dead count mode -->
          <div id="liveDeadDiv" class="hidden">
            <div class="form-group">
              <label class="form-label">Live Cell Count</label>
              <input id="liveCount" type="number" min="0" class="form-control" placeholder="Enter live cell count">
            </div>
            <div class="form-group">
              <label class="form-label">Dead Cell Count</label>
              <input id="deadCount" type="number" min="0" class="form-control" placeholder="Enter dead cell count">
            </div>
            <div class="form-group">
              <label class="form-label">Total (auto-calculated)</label>
              <input id="calculatedTotal" type="text" class="form-control readonly" readonly style="background: #f0f0f0;">
            </div>
            <div class="form-group">
              <label class="form-label">Viability</label>
              <input id="viability" type="text" class="form-control readonly" readonly style="background: #e8f5e9;">
            </div>
            <div class="form-group">
              <label class="form-label">Calculate based on</label>
              <select id="calcBasedOn" class="form-control">
                <option value="total" selected>Total Count (Live + Dead)</option>
                <option value="live">Live Count Only</option>
              </select>
            </div>
          </div>

          <div class="form-group">
            <label class="form-label">Number of Squares Counted</label>
            <select id="squares" class="form-control">
              <option>1</option>
              <option>2</option>
              <option>3</option>
              <option selected>4</option>
              <option>5</option>
              <option>6</option>
              <option>7</option>
              <option>8</option>
              <option>9</option>
            </select>
          </div>

          <div class="form-group">
            <label class="form-label">Dilution Factor (1:x)</label>
            <input id="dilution" type="number" min="1" step="1" value="5" class="form-control">
          </div>
        </div>

        <!-- Stock concentration input -->
        <div id="stockPanel" class="form-group hidden">
          <label class="form-label">Stock Concentration (cells/mL)</label>
          <div class="stock-input-wrapper">
            <input id="knownStockConc" type="number" min="0" step="1" placeholder="e.g. 1200000" class="form-control">
            <button id="millionBtn" type="button" class="btn btn-secondary">√ó10‚Å∂</button>
          </div>
        </div>
      </div>

      <!-- Plate Seeding Card -->
      <div id="seedingCard" class="card seeding-card">
        <h2 class="card-title">
          <span class="card-icon">üß´</span>
          Plate Seeding Setup
        </h2>
        
        <div class="form-group">
          <label class="form-label">Plate Type</label>
          <select id="plate" class="form-control">
            <option value="96" selected>96-well plate</option>
            <option value="48">48-well plate</option>
            <option value="24">24-well plate</option>
            <option value="12">12-well plate</option>
            <option value="6">6-well plate</option>
          </select>
        </div>

        <div class="form-group">
          <label class="form-label">Seeding Mode</label>
          <select id="mode" class="form-control">
            <option value="cells" selected>Target cells/well</option>
            <option value="conf">Target % confluence</option>
          </select>
        </div>

        <div id="targetCellDiv" class="form-group">
          <label class="form-label">Target Cells per Well</label>
          <input id="targetCells" type="number" min="1" class="form-control" placeholder="e.g. 10000">
        </div>

        <div id="confDiv" class="form-group hidden">
          <label class="form-label">Target % Confluence</label>
          <input id="targetConf" type="number" min="1" max="100" class="form-control" placeholder="e.g. 70">
          <label class="form-label" style="margin-top: 10px;">Cells at 100% confluence (optional)</label>
          <input id="baseline" type="number" min="1" class="form-control" placeholder="Leave blank for default">
        </div>

        <div class="form-group">
          <label class="form-label">Well Calculation Method</label>
          <select id="wellMode" class="form-control">
            <option value="manual" selected>Manual entry</option>
            <option value="plates">Whole plates</option>
            <option value="grid">Columns √ó Rows</option>
          </select>
        </div>

        <div id="manualWellDiv" class="form-group">
          <label class="form-label">Number of Wells</label>
          <input id="numWells" type="number" min="1" max="96" class="form-control" placeholder="e.g. 24">
          <label class="form-label" style="margin-top: 10px;">Replicate Plates</label>
          <input id="numManualPlates" type="number" min="1" value="1" class="form-control">
        </div>

        <div id="plateCountDiv" class="form-group hidden">
          <label class="form-label">Number of Plates</label>
          <input id="numPlates" type="number" min="0.5" step="0.5" class="form-control" placeholder="e.g. 2">
          <label class="form-label" style="margin-top: 10px;">PBS Border?</label>
          <select id="pbsBorder" class="form-control">
            <option value="no" selected>No</option>
            <option value="yes">Yes</option>
          </select>
        </div>

        <div id="gridDiv" class="form-group hidden">
          <label class="form-label">Columns</label>
          <input id="numCols" type="number" min="1" max="12" class="form-control">
          <label class="form-label" style="margin-top: 10px;">Rows</label>
          <input id="numRows" type="number" min="1" max="8" class="form-control">
          <label class="form-label" style="margin-top: 10px;">Replicate Plates</label>
          <input id="numGridPlates" type="number" min="1" value="1" class="form-control">
        </div>

        <div class="form-group">
          <label id="volLabel" class="form-label">Volume per Well (¬µL)</label>
          <input id="mediaPerWell" type="number" min="1" class="form-control" value="100">
        </div>

        <div class="form-group">
          <label class="form-label">Extra Volume (%)</label>
          <input id="overage" type="number" min="0" value="10" class="form-control">
        </div>

        <div class="form-group">
          <label class="form-label">Optimize For</label>
          <select id="optimise" class="form-control">
            <option value="least" selected>Least cells required</option>
            <option value="easy">Easy pipetting volumes</option>
          </select>
        </div>
      </div>

      <!-- Freezing Card -->
      <div id="freezingCard" class="card freezing-card hidden">
        <h2 class="card-title">
          <span class="card-icon">‚ùÑÔ∏è</span>
          Freezing Setup
        </h2>
        
        <div class="form-group">
          <label class="form-label">Cells per Vial</label>
          <input id="cellsPerVial" type="number" min="1" step="1" placeholder="e.g. 1000000" class="form-control">
        </div>
        
        <div class="form-group">
          <label class="form-label">Volume per Vial (mL)</label>
          <input id="volPerVialMl" type="number" min="0.1" step="0.1" placeholder="e.g. 1.0" class="form-control">
        </div>
        
        <div class="form-group">
          <label class="form-label">Minimum Vials (optional)</label>
          <input id="minVials" type="number" min="1" step="1" placeholder="Leave blank for auto" class="form-control">
        </div>
        
        <p style="font-size: 0.9rem; color: #718096; margin-top: 10px;">
          üí° Enter either cells/vial or volume/vial - the other will auto-calculate
        </p>
      </div>
    </div>

    <!-- Results Cards -->
    <div id="seedingResults" class="card results-card">
      <h2 class="card-title">
        <span class="card-icon">üìä</span>
        Seeding Results
      </h2>
      
      <div class="result-grid">
        <div class="result-item">
          <div class="result-label">Avg cells/square</div>
          <input id="outAvgSq" class="result-value" type="text" readonly>
        </div>
        <div class="result-item">
          <div class="result-label">Concentration</div>
          <input id="outConc" class="result-value" type="text" readonly>
        </div>
        <div class="result-item">
          <div class="result-label">Wells to seed</div>
          <input id="outWells" class="result-value" type="text" readonly>
        </div>
        <div class="result-item">
          <div class="result-label">Cells per well</div>
          <input id="outCellsPerWell" class="result-value" type="text" readonly>
        </div>
        <div class="result-item">
          <div class="result-label">Total cells needed</div>
          <input id="outTotalCells" class="result-value" type="text" readonly>
        </div>
        <div class="result-item">
          <div class="result-label">With <span id="extraPct">10</span>% extra</div>
          <input id="outOverCells" class="result-value" type="text" readonly>
        </div>
        <div class="result-item">
          <div class="result-label">Required conc.</div>
          <input id="outReqConc" class="result-value" type="text" readonly>
        </div>
        <div class="result-item">
          <div class="result-label">Final volume</div>
          <input id="outMixTotal" class="result-value" type="text" readonly>
        </div>
        <div class="result-item wide">
          <div class="result-label">Cell suspension volume</div>
          <input id="outOrigVol" class="result-value" type="text" readonly style="background: #eef9f1; border-color: #cfe9d7;">
        </div>
        <div class="result-item wide">
          <div class="result-label">Media volume</div>
          <input id="outMediaVol" class="result-value" type="text" readonly style="background: #ffecec; border-color: #f4b5b5;">
        </div>
      </div>
      
      <div id="instructionBox" class="instruction-box"></div>
    </div>

    <div id="freezingResults" class="card results-card hidden">
      <h2 class="card-title">
        <span class="card-icon">üìä</span>
        Freezing Results
      </h2>
      
      <div class="result-grid">
        <div class="result-item">
          <div class="result-label">Concentration</div>
          <input id="fr_conc" class="result-value" type="text" readonly>
        </div>
        <div class="result-item">
          <div class="result-label">Cells/vial</div>
          <input id="fr_cells_per_vial" class="result-value" type="text" readonly>
        </div>
        <div class="result-item">
          <div class="result-label">Volume/vial</div>
          <input id="fr_vol_per_vial" class="result-value" type="text" readonly>
        </div>
        <div class="result-item">
          <div class="result-label">Number of vials</div>
          <input id="fr_num_vials" class="result-value" type="text" readonly>
        </div>
        <div class="result-item wide">
          <div class="result-label">Total cells required</div>
          <input id="fr_total_cells" class="result-value" type="text" readonly>
        </div>
        <div class="result-item wide">
          <div class="result-label">Total volume required</div>
          <input id="fr_total_vol" class="result-value" type="text" readonly>
        </div>
        <div class="result-item wide">
          <div class="result-label">Cell suspension needed</div>
          <input id="fr_cell_vol" class="result-value" type="text" readonly style="background: #eef9f1; border-color: #cfe9d7;">
        </div>
        <div class="result-item wide">
          <div class="result-label">Freezing media needed</div>
          <input id="fr_media_vol" class="result-value" type="text" readonly style="background: #e3f2fd; border-color: #90caf9;">
        </div>
      </div>
      
      <div id="freezingInstructionBox" class="instruction-box"></div>
    </div>

    <!-- Export Card -->
    <div id="exportCard" class="card">
      <h2 class="card-title">
        <span class="card-icon">üíæ</span>
        Data Export & Session
      </h2>

      <!-- Name entry for saved counts -->
      <div class="form-group">
        <label class="form-label">Experiment Name</label>
        <input id="experimentName" type="text" class="form-control" placeholder="e.g. 20250101 cell counts">
      </div>

      <div class="form-group">
        <label class="form-label">Sample/Cell Line Name</label>
        <input id="countName" type="text" class="form-control" placeholder="e.g. Cell line A">
      </div>

      <!-- Filename preview -->
      <div class="form-group">
        <label class="form-label">Export Filename Preview</label>
        <div id="filenamePreview" style="padding: 10px 14px; background: #f7fafc; border: 2px dashed #e2e8f0; border-radius: 12px; font-family: monospace; color: #4a5568; font-size: 0.95rem;"></div>
      </div>
      
      <div class="button-group">
        <button id="saveCountBtn" class="btn btn-primary">Save Count</button>
        <button id="downloadCsvBtn" class="btn btn-secondary hidden">Download Excel</button>
        <button id="resetSessionBtn" class="btn btn-warning">New Session</button>
      </div>
      
      <table id="countsTable" class="data-table hidden">
        <thead>
          <tr>
            <th>#</th>
            <th>Sample</th>
            <th>Conc</th>
            <th>Cells/well</th>
            <th>Cell Vol</th>
            <th>Media Vol</th>
          </tr>
        </thead>
        <tbody id="countsTableBody"></tbody>
      </table>
    </div>
  </div>

  <script>
    (function() {
      'use strict';

      // Constants
      const CORNING_BASELINE = {
        "96": 32000,
        "48": 50000,
        "24": 190000,
        "12": 380000,
        "6": 600000
      };

      const PLATE_GEOM = {
        "96": [8, 12],
        "48": [6, 8],
        "24": [4, 6],
        "12": [3, 4],
        "6": [2, 3]
      };

      const DEFAULT_VOL = {
        "96": 0.100,
        "48": 0.250,
        "24": 0.500,
        "12": 1.000,
        "6": 2.000
      };

      // Storage
      const STORAGE_KEY = 'cell_calc_v6';
      const MS_TTL = 24 * 60 * 60 * 1000;
      window.countsList = [];

      // Utilities
      const $ = id => document.getElementById(id);
      const nz = (v, d = 0) => {
        const n = parseFloat(v);
        return isNaN(n) ? d : n;
      };
      const clamp = (v, min, max) => Math.min(Math.max(v, min), max);
      const fmtVol = ml => ml < 1 ? Math.round(ml * 1000) + ' ¬µL' : ml.toFixed(2) + ' mL';

      // Generate default experiment name with today's date in YYYYMMDD format
      function getDefaultExperimentName() {
        const now = new Date();
        const year = now.getFullYear();
        const month = String(now.getMonth() + 1).padStart(2, '0');
        const day = String(now.getDate()).padStart(2, '0');
        return `${year}${month}${day}`;
      }

      // Update experiment name with current date if still using default pattern
      function updateExperimentNameDate() {
        const input = $('experimentName');
        if (!input) return;

        // Only update if empty or matches the default pattern (YYYYMMDD)
        const defaultPattern = /^\d{8}$/;
        if (input.value === '' || defaultPattern.test(input.value)) {
          input.value = getDefaultExperimentName();
        }
        updateFilenamePreview();
      }

      // Generate the export filename from experiment name
      function getExportFilename() {
        const experimentName = $('experimentName')?.value || getDefaultExperimentName();
        return `${experimentName} Cell counts`;
      }

      // Update the filename preview display
      function updateFilenamePreview() {
        const preview = $('filenamePreview');
        if (!preview) return;
        const filename = getExportFilename();
        const safeFilename = filename.replace(/[^a-z0-9 ]/gi, '_');
        preview.textContent = `${safeFilename}.xlsx`;
      }

      // UI Management
      function updateVisibility() {
        const measurementMode = $('measurementMode')?.value || 'haem';
        const purposeMode = $('purposeMode')?.value || 'seeding';
        const countingMode = $('countingMode')?.value || 'total';

        // Measurement mode
        $('haemoFields')?.classList.toggle('hidden', measurementMode !== 'haem');
        $('stockPanel')?.classList.toggle('hidden', measurementMode !== 'stock');

        // Counting mode (only visible for haemocytometer mode)
        $('countingModeDiv')?.classList.toggle('hidden', measurementMode !== 'haem');

        // Total vs Live+Dead counting fields
        if (measurementMode === 'haem') {
          $('totalCountDiv')?.classList.toggle('hidden', countingMode !== 'total');
          $('liveDeadDiv')?.classList.toggle('hidden', countingMode !== 'liveDead');
        }

        // Purpose mode
        $('seedingCard')?.classList.toggle('hidden', purposeMode !== 'seeding');
        $('freezingCard')?.classList.toggle('hidden', purposeMode !== 'freezing');
        $('seedingResults')?.classList.toggle('hidden', purposeMode !== 'seeding');
        $('freezingResults')?.classList.toggle('hidden', purposeMode !== 'freezing');
        $('exportCard')?.classList.toggle('hidden', purposeMode !== 'seeding');

        // Seeding sub-modes
        if (purposeMode === 'seeding') {
          const seedingMode = $('mode')?.value || 'cells';
          $('targetCellDiv')?.classList.toggle('hidden', seedingMode !== 'cells');
          $('confDiv')?.classList.toggle('hidden', seedingMode !== 'conf');
          
          const wellMode = $('wellMode')?.value || 'manual';
          $('manualWellDiv')?.classList.toggle('hidden', wellMode !== 'manual');
          $('plateCountDiv')?.classList.toggle('hidden', wellMode !== 'plates');
          $('gridDiv')?.classList.toggle('hidden', wellMode !== 'grid');
        }

        updateVolLabel();
      }

      function updateVolLabel() {
        const plate = $('plate')?.value || '96';
        const isMl = plate === '12' || plate === '6';
        const label = $('volLabel');
        if (label) {
          label.textContent = `Volume per Well (${isMl ? 'mL' : '¬µL'})`;
        }
      }

      function setDefaultVolume() {
        const plate = $('plate')?.value || '96';
        const ml = DEFAULT_VOL[plate] || 0.100;
        const input = $('mediaPerWell');
        if (!input) return;
        
        if (plate === '12' || plate === '6') {
          input.value = ml.toFixed(2);
          input.min = '0.1';
        } else {
          input.value = Math.round(ml * 1000);
          input.min = '1';
        }
      }

      // Calculate and update live/dead totals and viability
      function updateLiveDeadCalculations() {
        const countingMode = $('countingMode')?.value || 'total';
        if (countingMode !== 'liveDead') return;

        const live = Math.max(0, nz($('liveCount')?.value, 0));
        const dead = Math.max(0, nz($('deadCount')?.value, 0));
        const total = live + dead;

        $('calculatedTotal').value = total > 0 ? total.toString() : '';

        if (total > 0) {
          const viability = (live / total) * 100;
          $('viability').value = viability.toFixed(1) + '%';
        } else {
          $('viability').value = '';
        }
      }

      // Get the cell count to use for calculations based on counting mode
      function getEffectiveCellCount() {
        const countingMode = $('countingMode')?.value || 'total';

        if (countingMode === 'total') {
          return Math.max(0, nz($('totalCount')?.value, 0));
        }

        // Live + Dead mode
        const live = Math.max(0, nz($('liveCount')?.value, 0));
        const dead = Math.max(0, nz($('deadCount')?.value, 0));
        const total = live + dead;
        const calcBasedOn = $('calcBasedOn')?.value || 'total';

        return calcBasedOn === 'live' ? live : total;
      }

      // Calculations
      function getStockConcentration() {
        if ($('measurementMode')?.value === 'stock') {
          return nz($('knownStockConc')?.value, 0);
        }

        const cellCount = getEffectiveCellCount();
        const squares = clamp(nz($('squares')?.value, 4), 1, 9);
        const dil = Math.max(1, nz($('dilution')?.value, 5));
        const avg = cellCount / squares;
        return avg / 0.0001 * dil;
      }

      function calculateHaemocytometer() {
        // Update live/dead calculations first if in that mode
        updateLiveDeadCalculations();

        const cellCount = getEffectiveCellCount();
        const squares = clamp(nz($('squares')?.value, 4), 1, 9);
        const dil = Math.max(1, nz($('dilution')?.value, 5));
        const avg = cellCount / squares;
        const cMl = avg / 0.0001 * dil;

        if ($('measurementMode')?.value === 'haem') {
          $('outAvgSq').value = avg ? avg.toFixed(2) : '';
        } else {
          $('outAvgSq').value = '';
        }
        $('outConc').value = cMl ? Math.round(cMl).toLocaleString() + ' cells/mL' : '';

        return { avg, cMl };
      }

      function totalWells() {
        const wm = $('wellMode')?.value || 'manual';
        const plate = $('plate')?.value || '96';
        
        if (wm === 'manual') {
          const wells = clamp(nz($('numWells')?.value, 0), 1, parseInt(plate));
          const reps = Math.max(1, nz($('numManualPlates')?.value, 1));
          return wells * reps;
        }
        
        if (wm === 'grid') {
          const [maxR, maxC] = PLATE_GEOM[plate];
          const c = clamp(nz($('numCols')?.value, 0), 1, maxC);
          const r = clamp(nz($('numRows')?.value, 0), 1, maxR);
          const p = Math.max(1, nz($('numGridPlates')?.value, 1));
          return c * r * p;
        }
        
        // Plates mode
        const pbs = ($('pbsBorder')?.value || 'no') === 'yes';
        const [r, c] = PLATE_GEOM[plate];
        const per = pbs ? Math.max(r - 2, 0) * Math.max(c - 2, 0) : parseInt(plate);
        const plates = Math.max(0.5, nz($('numPlates')?.value, 0));
        return per * plates;
      }

      function updatePlateConstraints() {
        const plate = $('plate')?.value || '96';
        const plateNum = parseInt(plate);
        const [maxRows, maxCols] = PLATE_GEOM[plate];
        
        // Update well number constraints and placeholder
        const numWells = $('numWells');
        if (numWells) {
          numWells.max = plateNum;
          numWells.placeholder = `e.g. ${Math.min(24, plateNum)}`;
        }
        
        // Update column/row constraints and labels
        const numCols = $('numCols');
        const numRows = $('numRows');
        const colLabel = $('colLabel');
        const rowLabel = $('rowLabel');
        
        if (numCols) {
          numCols.max = maxCols;
          numCols.placeholder = `e.g. ${Math.min(3, maxCols)}`;
        }
        if (numRows) {
          numRows.max = maxRows;
          numRows.placeholder = `e.g. ${Math.min(2, maxRows)}`;
        }
        if (colLabel) colLabel.textContent = `Columns (1-${maxCols})`;
        if (rowLabel) rowLabel.textContent = `Rows (1-${maxRows})`;
      }

      function handleMillionCells() {
        const checkbox = $('millionCells');
        const input = $('knownStockConc');
        if (!checkbox || !input) return;
        
        if (checkbox.checked) {
          // Convert to millions
          const current = parseFloat(input.value) || 0;
          if (current > 1000) {
            input.value = (current / 1000000).toFixed(2);
          }
          input.step = '0.01';
          input.placeholder = 'e.g. 1.2';
        } else {
          // Convert back to cells/mL
          const current = parseFloat(input.value) || 0;
          if (current < 1000) {
            input.value = Math.round(current * 1000000);
          }
          input.step = '1';
          input.placeholder = 'e.g. 1200000';
        }
      }

      function targetCellsPerWell() {
        if (($('mode')?.value || 'cells') === 'cells') {
          return Math.max(1, nz($('targetCells')?.value, 0));
        }
        const pct = clamp(nz($('targetConf')?.value, 0), 1, 100);
        const baseline = nz($('baseline')?.value) || CORNING_BASELINE[$('plate')?.value || '96'] || 0;
        return baseline * (pct / 100);
      }

      function calculateSeeding() {
        const stockConc = getStockConcentration();
        calculateHaemocytometer();
        
        const wells = Math.round(totalWells());
        const targetPerW = targetCellsPerWell();
        const overPct = Math.max(0, nz($('overage')?.value, 10));
        
        $('extraPct').textContent = String(overPct);
        
        const plate = $('plate')?.value || '96';
        const isMlInput = plate === '12' || plate === '6';
        const rawVol = nz($('mediaPerWell')?.value, 0);
        const perWellMl = isMlInput ? rawVol : (rawVol / 1000);
        
        const totalCells = targetPerW * wells;
        const totalCellsOver = totalCells * (1 + overPct / 100);
        
        const concentration = ($('measurementMode')?.value === 'stock') ? stockConc : getStockConcentration();
        
        const reqMixConc = perWellMl > 0 ? (targetPerW / perWellMl) : 0;
        const baseFinalMl = perWellMl * wells * (1 + overPct / 100);
        
        // Round final volume
        let finalMixMl = baseFinalMl;
        const mode = $('optimise')?.value || 'least';
        if (finalMixMl < 1) {
          const step = mode === 'easy' ? 0.050 : 0.010;
          finalMixMl = Math.max(step, Math.round(finalMixMl / step) * step);
        } else {
          const step = mode === 'easy' ? 0.5 : 0.1;
          finalMixMl = Math.max(step, Math.round(finalMixMl / step) * step);
        }
        
        let stockInMixMl = concentration > 0 ? (reqMixConc / concentration) * finalMixMl : 0;
        let mediaMl = Math.max(0, finalMixMl - stockInMixMl);
        
        // Apply ease scaling
        if (mode === 'easy' && mediaMl > 0) {
          const step = mediaMl < 1 ? 0.050 : 0.5;
          const targetMedia = Math.ceil(mediaMl / step) * step;
          const scale = targetMedia / mediaMl;
          mediaMl = targetMedia;
          stockInMixMl *= scale;
          finalMixMl = mediaMl + stockInMixMl;
        }
        
        // Update outputs
        if ($('measurementMode')?.value === 'stock') {
          $('outConc').value = Math.round(stockConc).toLocaleString() + ' cells/mL';
        }
        
        $('outWells').value = wells.toString();
        $('outCellsPerWell').value = Math.round(targetPerW).toLocaleString() + ' cells';
        $('outTotalCells').value = Math.round(totalCells).toLocaleString();
        $('outOverCells').value = Math.round(totalCellsOver).toLocaleString();
        $('outOrigVol').value = fmtVol(stockInMixMl);
        $('outReqConc').value = Math.round(reqMixConc).toLocaleString() + ' cells/mL';
        $('outMixTotal').value = fmtVol(finalMixMl);
        $('outMediaVol').value = fmtVol(mediaMl);
        
        // Instruction
        const perWellText = fmtVol(perWellMl);
        const seedMode = $('mode')?.value || 'cells';
        const tail = seedMode === 'cells'
          ? `${perWellText} per well for ${Math.round(targetPerW).toLocaleString()} cells/well`
          : `${perWellText} per well for ${clamp(nz($('targetConf')?.value, 0), 1, 100)}% confluence`;
        
        const instruction = `Take ${fmtVol(stockInMixMl)} of cell suspension and dilute in ${fmtVol(mediaMl)} of media to a final concentration of ${Math.round(reqMixConc).toLocaleString()} cells/mL. Add ${tail}.`;
        
        $('instructionBox').innerHTML = instruction;
      }

      function calculateFreezing() {
        const stockConc = getStockConcentration();
        const cellsPerVial = nz($('cellsPerVial')?.value, 0);
        const volPerVialMl = nz($('volPerVialMl')?.value, 0);
        const minVials = nz($('minVials')?.value, 0);
        
        let finalCellsPerVial = cellsPerVial;
        let finalVolPerVial = volPerVialMl;
        
        if (cellsPerVial === 0 && volPerVialMl > 0 && stockConc > 0) {
          finalCellsPerVial = stockConc * volPerVialMl;
        } else if (volPerVialMl === 0 && cellsPerVial > 0 && stockConc > 0) {
          finalVolPerVial = cellsPerVial / stockConc;
        }
        
        let numVials = 0;
        if (finalCellsPerVial > 0) {
          const totalCellsAvail = stockConc * 10; // Default 10mL
          numVials = Math.ceil(totalCellsAvail / finalCellsPerVial);
          if (minVials > 0) {
            numVials = Math.max(numVials, minVials);
          }
        }
        
        const cellVolPerVialMl = (stockConc > 0 && finalCellsPerVial > 0) ? (finalCellsPerVial / stockConc) : 0;
        const mediaPerVialMl = Math.max(0, finalVolPerVial - cellVolPerVialMl);
        const totalCellVolMl = cellVolPerVialMl * numVials;
        const totalMediaMl = mediaPerVialMl * numVials;
        const totalCells = finalCellsPerVial * numVials;
        const totalVolMl = finalVolPerVial * numVials;
        
        $('fr_conc').value = stockConc > 0 ? Math.round(stockConc).toLocaleString() + ' cells/mL' : '';
        $('fr_cells_per_vial').value = finalCellsPerVial > 0 ? Math.round(finalCellsPerVial).toLocaleString() + ' cells' : '';
        $('fr_vol_per_vial').value = finalVolPerVial > 0 ? finalVolPerVial.toFixed(2) + ' mL' : '';
        $('fr_num_vials').value = numVials > 0 ? numVials.toString() : '';
        $('fr_total_cells').value = totalCells > 0 ? Math.round(totalCells).toLocaleString() + ' cells' : '';
        $('fr_total_vol').value = totalVolMl > 0 ? totalVolMl.toFixed(2) + ' mL' : '';
        $('fr_cell_vol').value = totalCellVolMl > 0 ? totalCellVolMl.toFixed(2) + ' mL' : '';
        $('fr_media_vol').value = totalMediaMl > 0 ? totalMediaMl.toFixed(2) + ' mL' : '';
        
        if (numVials > 0 && finalCellsPerVial > 0 && finalVolPerVial > 0) {
          const instruction = `Prepare ${numVials} vials with ${Math.round(finalCellsPerVial).toLocaleString()} cells in ${finalVolPerVial.toFixed(2)} mL each. Per vial: ${fmtVol(cellVolPerVialMl)} cells + ${fmtVol(mediaPerVialMl)} freezing media.`;
          $('freezingInstructionBox').textContent = instruction;
        }
      }

      function validate() {
        let valid = true;
        document.querySelectorAll('.invalid').forEach(e => e.classList.remove('invalid'));

        const measurementMode = $('measurementMode')?.value || 'haem';
        const countingMode = $('countingMode')?.value || 'total';
        const purposeMode = $('purposeMode')?.value || 'seeding';

        // Check required fields
        const requiredFields = [];

        if (measurementMode === 'haem') {
          if (countingMode === 'total') {
            requiredFields.push('totalCount');
          } else {
            // Live + Dead mode - at least one count is required
            const live = nz($('liveCount')?.value, 0);
            const dead = nz($('deadCount')?.value, 0);
            if (live === 0 && dead === 0) {
              $('liveCount')?.classList.add('invalid');
              valid = false;
            }
          }
          requiredFields.push('squares', 'dilution');
        } else {
          requiredFields.push('knownStockConc');
        }
        
        if (purposeMode === 'seeding') {
          requiredFields.push('plate', 'mediaPerWell');
          if ($('mode')?.value === 'cells') {
            requiredFields.push('targetCells');
          } else {
            requiredFields.push('targetConf');
          }
          
          const wm = $('wellMode')?.value || 'manual';
          if (wm === 'manual') requiredFields.push('numWells');
          if (wm === 'plates') requiredFields.push('numPlates');
          if (wm === 'grid') requiredFields.push('numCols', 'numRows');
        }
        
        requiredFields.forEach(id => {
          const el = $(id);
          if (el && (!el.value || el.value.trim() === '')) {
            el.classList.add('invalid');
            valid = false;
          }
        });
        
        return valid;
      }

      function recalc() {
        if (!validate()) {
          // Clear outputs if invalid
          ['outAvgSq', 'outConc', 'outWells', 'outCellsPerWell', 'outTotalCells', 'outOverCells',
           'outOrigVol', 'outReqConc', 'outMixTotal', 'outMediaVol'].forEach(id => {
            const el = $(id);
            if (el) el.value = '';
          });
          $('instructionBox').innerHTML = '';
          return;
        }
        
        const purposeMode = $('purposeMode')?.value || 'seeding';
        
        if (purposeMode === 'seeding') {
          calculateSeeding();
        } else {
          calculateHaemocytometer();
          calculateFreezing();
        }
      }

      // Freezing field locking
      function updateFreezingFieldLocking() {
        const a = $('cellsPerVial');
        const b = $('volPerVialMl');
        if (!a || !b) return;
        
        const purposeMode = $('purposeMode')?.value || 'seeding';
        if (purposeMode !== 'freezing') {
          a.readOnly = false;
          b.readOnly = false;
          a.classList.remove('readonly');
          b.classList.remove('readonly');
          return;
        }
        
        const aFilled = a.value !== '' && !isNaN(parseFloat(a.value));
        const bFilled = b.value !== '' && !isNaN(parseFloat(b.value));
        
        if (aFilled && !bFilled) {
          b.readOnly = true;
          b.classList.add('readonly');
          b.placeholder = 'Auto-calculated';
        } else if (!aFilled && bFilled) {
          a.readOnly = true;
          a.classList.add('readonly');
          a.placeholder = 'Auto-calculated';
        } else {
          a.readOnly = false;
          b.readOnly = false;
          a.classList.remove('readonly');
          b.classList.remove('readonly');
          a.placeholder = 'e.g. 1000000';
          b.placeholder = 'e.g. 1.0';
        }
      }

      // Data management
      function saveCount() {
        const measurementMode = $('measurementMode')?.value || 'haem';
        const countingMode = $('countingMode')?.value || 'total';
        const seedingMode = $('mode')?.value || 'cells';
        const wellMode = $('wellMode')?.value || 'manual';
        const plate = $('plate')?.value || '96';

        // Build a comprehensive row object from all inputs and outputs
        const row = {
          // Identification
          experimentName: $('experimentName')?.value || getDefaultExperimentName(),
          sampleName: $('countName')?.value || '',
          timestamp: new Date().toLocaleString(),

          // Measurement inputs
          measurementMode: measurementMode,
          countingMode: measurementMode === 'haem' ? countingMode : '',
          totalCount: measurementMode === 'haem' && countingMode === 'total' ? ($('totalCount')?.value || '') : '',
          liveCount: measurementMode === 'haem' && countingMode === 'liveDead' ? ($('liveCount')?.value || '') : '',
          deadCount: measurementMode === 'haem' && countingMode === 'liveDead' ? ($('deadCount')?.value || '') : '',
          viability: measurementMode === 'haem' && countingMode === 'liveDead' ? ($('viability')?.value || '') : '',
          calcBasedOn: measurementMode === 'haem' && countingMode === 'liveDead' ? ($('calcBasedOn')?.value || '') : '',
          squares: measurementMode === 'haem' ? ($('squares')?.value || '') : '',
          dilutionFactor: measurementMode === 'haem' ? ($('dilution')?.value || '') : '',
          knownStockConc: measurementMode === 'stock' ? ($('knownStockConc')?.value || '') : '',

          // Plate setup inputs
          plateType: plate + '-well',
          seedingMode: seedingMode,
          targetCells: seedingMode === 'cells' ? ($('targetCells')?.value || '') : '',
          targetConfluence: seedingMode === 'conf' ? ($('targetConf')?.value || '') : '',
          baseline: seedingMode === 'conf' ? ($('baseline')?.value || '') : '',
          wellMode: wellMode,
          numWells: wellMode === 'manual' ? ($('numWells')?.value || '') : '',
          numManualPlates: wellMode === 'manual' ? ($('numManualPlates')?.value || '') : '',
          numPlates: wellMode === 'plates' ? ($('numPlates')?.value || '') : '',
          pbsBorder: wellMode === 'plates' ? ($('pbsBorder')?.value || '') : '',
          numCols: wellMode === 'grid' ? ($('numCols')?.value || '') : '',
          numRows: wellMode === 'grid' ? ($('numRows')?.value || '') : '',
          numGridPlates: wellMode === 'grid' ? ($('numGridPlates')?.value || '') : '',
          mediaPerWell: $('mediaPerWell')?.value || '',
          overage: $('overage')?.value || '',
          optimiseFor: $('optimise')?.value || '',

          // Results/outputs
          avgPerSquare: $('outAvgSq')?.value || '',
          concentration: $('outConc')?.value || '',
          wellsToSeed: $('outWells')?.value || '',
          cellsPerWell: $('outCellsPerWell')?.value || '',
          totalCellsNeeded: $('outTotalCells')?.value || '',
          totalCellsWithExtra: $('outOverCells')?.value || '',
          requiredConc: $('outReqConc')?.value || '',
          finalVolume: $('outMixTotal')?.value || '',
          cellSuspensionVol: $('outOrigVol')?.value || '',
          mediaVolume: $('outMediaVol')?.value || ''
        };

        window.countsList.push(row);
        // Clear the sample name field after saving (keep experiment name)
        const nameInput = $('countName');
        if (nameInput) nameInput.value = '';

        renderTable();
        saveState();
      }

      function renderTable() {
        const tbody = $('countsTableBody');
        if (!tbody) return;

        tbody.innerHTML = '';
        window.countsList.forEach((r, i) => {
          const tr = document.createElement('tr');
          // First cell contains the index and a delete button
          const indexTd = document.createElement('td');
          const indexSpan = document.createElement('span');
          indexSpan.textContent = i + 1;
          indexSpan.style.marginRight = '8px';
          const delBtn = document.createElement('button');
          delBtn.textContent = '√ó';
          delBtn.title = 'Delete';
          delBtn.className = 'btn btn-warning';
          delBtn.style.padding = '2px 6px';
          delBtn.style.fontSize = '0.8rem';
          delBtn.addEventListener('click', () => {
            window.countsList.splice(i, 1);
            renderTable();
            saveState();
          });
          indexTd.appendChild(indexSpan);
          indexTd.appendChild(delBtn);
          tr.appendChild(indexTd);
          // Populate remaining cells with summary data
          const values = [
            r.sampleName || r.name || '',  // Support both old and new format
            r.concentration || r.conc || '',
            r.cellsPerWell || '',
            r.cellSuspensionVol || r.origVol || '',
            r.mediaVolume || r.mediaVol || ''
          ];
          values.forEach(v => {
            const td = document.createElement('td');
            td.textContent = v || '';
            tr.appendChild(td);
          });
          tbody.appendChild(tr);
        });

        $('countsTable')?.classList.toggle('hidden', window.countsList.length === 0);
        $('downloadCsvBtn')?.classList.toggle('hidden', window.countsList.length === 0);
      }

      // Field labels for export (human-readable names)
      const FIELD_LABELS = {
        experimentName: 'Experiment Name',
        sampleName: 'Sample/Cell Line Name',
        timestamp: 'Timestamp',
        measurementMode: 'Measurement Mode',
        countingMode: 'Counting Mode',
        totalCount: 'Total Cell Count',
        liveCount: 'Live Cell Count',
        deadCount: 'Dead Cell Count',
        viability: 'Viability (%)',
        calcBasedOn: 'Calculation Based On',
        squares: 'Squares Counted',
        dilutionFactor: 'Dilution Factor',
        knownStockConc: 'Known Stock Concentration',
        plateType: 'Plate Type',
        seedingMode: 'Seeding Mode',
        targetCells: 'Target Cells/Well',
        targetConfluence: 'Target % Confluence',
        baseline: 'Cells at 100% Confluence',
        wellMode: 'Well Calculation Method',
        numWells: 'Number of Wells',
        numManualPlates: 'Replicate Plates (Manual)',
        numPlates: 'Number of Plates',
        pbsBorder: 'PBS Border',
        numCols: 'Columns',
        numRows: 'Rows',
        numGridPlates: 'Replicate Plates (Grid)',
        mediaPerWell: 'Volume per Well',
        overage: 'Extra Volume (%)',
        optimiseFor: 'Optimise For',
        avgPerSquare: 'Avg Cells/Square',
        concentration: 'Stock Concentration',
        wellsToSeed: 'Wells to Seed',
        cellsPerWell: 'Cells per Well',
        totalCellsNeeded: 'Total Cells Needed',
        totalCellsWithExtra: 'Total Cells (with Extra)',
        requiredConc: 'Required Concentration',
        finalVolume: 'Final Volume',
        cellSuspensionVol: 'Cell Suspension Volume',
        mediaVolume: 'Media Volume'
      };

      // Fields to include in export (in order)
      const EXPORT_FIELDS = [
        'experimentName',
        'sampleName',
        'timestamp',
        'measurementMode',
        'countingMode',
        'totalCount',
        'liveCount',
        'deadCount',
        'viability',
        'calcBasedOn',
        'squares',
        'dilutionFactor',
        'knownStockConc',
        'plateType',
        'seedingMode',
        'targetCells',
        'targetConfluence',
        'baseline',
        'wellMode',
        'numWells',
        'numManualPlates',
        'numPlates',
        'pbsBorder',
        'numCols',
        'numRows',
        'numGridPlates',
        'mediaPerWell',
        'overage',
        'optimiseFor',
        'avgPerSquare',
        'concentration',
        'wellsToSeed',
        'cellsPerWell',
        'totalCellsNeeded',
        'totalCellsWithExtra',
        'requiredConc',
        'finalVolume',
        'cellSuspensionVol',
        'mediaVolume'
      ];

      async function downloadExcel() {
        if (!window.countsList.length) return;

        // Check if ExcelJS is available
        if (typeof ExcelJS === 'undefined') {
          alert('Excel export library not loaded. Please try again or check your internet connection.');
          return;
        }

        const btn = $('downloadCsvBtn');
        const originalText = btn.textContent;
        btn.textContent = 'Generating...';
        btn.disabled = true;

        try {
          // Create workbook
          const workbook = new ExcelJS.Workbook();
          workbook.creator = 'Haemocytometer Helper v1.1';
          workbook.created = new Date();

          // Create Data sheet
          const dataSheet = workbook.addWorksheet('Cell Count Data');

          // Get experiment name from first record for filename
          const experimentName = window.countsList[0]?.experimentName || getDefaultExperimentName();

          // Build transposed data: fields as rows, samples as columns
          // Row 1: Header row with "Field" in A1 and sample numbers in B1, C1, etc.
          const headerRow = ['Field'];
          for (let i = 0; i < window.countsList.length; i++) {
            headerRow.push(`Sample ${i + 1}`);
          }
          dataSheet.addRow(headerRow);

          // Style header row
          const headerRowRef = dataSheet.getRow(1);
          headerRowRef.font = { bold: true, color: { argb: 'FFFFFFFF' } };
          headerRowRef.fill = {
            type: 'pattern',
            pattern: 'solid',
            fgColor: { argb: 'FF667eea' }
          };
          headerRowRef.alignment = { horizontal: 'center' };

          // Add data rows (each field becomes a row)
          EXPORT_FIELDS.forEach((fieldKey) => {
            const row = [FIELD_LABELS[fieldKey] || fieldKey];
            window.countsList.forEach((record) => {
              // Handle both old and new record formats
              let value = record[fieldKey];
              // Fallback for old format records
              if (value === undefined) {
                if (fieldKey === 'sampleName') value = record.name || '';
                else if (fieldKey === 'concentration') value = record.conc || '';
                else if (fieldKey === 'avgPerSquare') value = record.avg || '';
                else if (fieldKey === 'cellSuspensionVol') value = record.origVol || '';
                else if (fieldKey === 'mediaVolume') value = record.mediaVol || '';
                else if (fieldKey === 'finalVolume') value = record.finalVol || '';
                else value = '';
              }
              row.push(value || '');
            });
            dataSheet.addRow(row);
          });

          // Set column widths
          dataSheet.getColumn(1).width = 30;
          for (let i = 2; i <= window.countsList.length + 1; i++) {
            dataSheet.getColumn(i).width = 20;
          }

          // Alternate row colors for readability
          for (let i = 2; i <= dataSheet.rowCount; i++) {
            const row = dataSheet.getRow(i);
            if (i % 2 === 0) {
              row.fill = {
                type: 'pattern',
                pattern: 'solid',
                fgColor: { argb: 'FFF7FAFC' }
              };
            }
          }

          // Add borders to all cells
          dataSheet.eachRow((row) => {
            row.eachCell((cell) => {
              cell.border = {
                top: { style: 'thin', color: { argb: 'FFE2E8F0' } },
                left: { style: 'thin', color: { argb: 'FFE2E8F0' } },
                bottom: { style: 'thin', color: { argb: 'FFE2E8F0' } },
                right: { style: 'thin', color: { argb: 'FFE2E8F0' } }
              };
            });
          });

          // Try to capture screenshot and add to a separate sheet
          if (typeof html2canvas !== 'undefined') {
            try {
              // Capture only the container (not the blue background)
              const container = document.querySelector('.container');
              if (container) {
                const canvas = await html2canvas(container, {
                  scale: 1.5,
                  useCORS: true,
                  allowTaint: true,
                  backgroundColor: '#ffffff'
                });

                // Create screenshot sheet
                const screenshotSheet = workbook.addWorksheet('Screenshot');

                // Convert canvas to base64
                const imageData = canvas.toDataURL('image/png').split(',')[1];

                // Add image to workbook
                const imageId = workbook.addImage({
                  base64: imageData,
                  extension: 'png'
                });

                // Calculate dimensions (fit to reasonable size)
                const maxWidth = 800;
                const scale = Math.min(1, maxWidth / canvas.width);
                const imgWidth = canvas.width * scale;
                const imgHeight = canvas.height * scale;

                // Add image to sheet
                screenshotSheet.addImage(imageId, {
                  tl: { col: 0, row: 0 },
                  ext: { width: imgWidth, height: imgHeight }
                });

                // Add title
                screenshotSheet.getCell('A1').value = '';
              }
            } catch (screenshotError) {
              console.warn('Could not capture screenshot:', screenshotError);
            }
          }

          // Generate and download file
          const buffer = await workbook.xlsx.writeBuffer();
          const blob = new Blob([buffer], {
            type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
          });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          // Use experiment name + "Cell counts" for filename
          const filename = getExportFilename();
          const safeFilename = filename.replace(/[^a-z0-9 ]/gi, '_');
          a.download = `${safeFilename}.xlsx`;
          a.click();
          URL.revokeObjectURL(url);

        } catch (error) {
          console.error('Excel export error:', error);
          alert('Error generating Excel file. Falling back to CSV export.');
          downloadCsvFallback();
        } finally {
          btn.textContent = originalText;
          btn.disabled = false;
        }
      }

      // Fallback CSV export if Excel fails
      function downloadCsvFallback() {
        if (!window.countsList.length) return;

        // Build CSV with transposed format
        let csv = '';
        const experimentName = window.countsList[0]?.experimentName || getDefaultExperimentName();

        // Header row
        csv += 'Field';
        for (let i = 0; i < window.countsList.length; i++) {
          csv += `,Sample ${i + 1}`;
        }
        csv += '\n';

        // Data rows
        EXPORT_FIELDS.forEach((fieldKey) => {
          csv += `"${FIELD_LABELS[fieldKey] || fieldKey}"`;
          window.countsList.forEach((record) => {
            let value = record[fieldKey];
            if (value === undefined) {
              if (fieldKey === 'sampleName') value = record.name || '';
              else if (fieldKey === 'concentration') value = record.conc || '';
              else if (fieldKey === 'avgPerSquare') value = record.avg || '';
              else if (fieldKey === 'cellSuspensionVol') value = record.origVol || '';
              else if (fieldKey === 'mediaVolume') value = record.mediaVol || '';
              else if (fieldKey === 'finalVolume') value = record.finalVol || '';
              else value = '';
            }
            // Escape commas and quotes in CSV
            const escaped = String(value || '').replace(/"/g, '""');
            csv += `,"${escaped}"`;
          });
          csv += '\n';
        });

        const blob = new Blob([csv], { type: 'text/csv' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        const filename = getExportFilename();
        const safeFilename = filename.replace(/[^a-z0-9 ]/gi, '_');
        a.download = `${safeFilename}.csv`;
        a.click();
        URL.revokeObjectURL(url);
      }

      function saveState() {
        const inputs = {};
        document.querySelectorAll('input, select').forEach(el => {
          if (el.id) inputs[el.id] = el.value;
        });
        
        localStorage.setItem(STORAGE_KEY, JSON.stringify({
          savedAt: Date.now(),
          inputs,
          countsList: window.countsList
        }));
      }

      function loadState() {
        try {
          const data = JSON.parse(localStorage.getItem(STORAGE_KEY) || '{}');
          if (data.savedAt && Date.now() - data.savedAt < MS_TTL) {
            Object.entries(data.inputs || {}).forEach(([id, value]) => {
              const el = $(id);
              if (el) el.value = value;
            });
            window.countsList = data.countsList || [];
            renderTable();
          }
        } catch (e) {}
      }

      // Initialize
      function init() {
        loadState();
        
        // Event listeners
        ['measurementMode', 'purposeMode', 'mode', 'wellMode', 'countingMode', 'calcBasedOn'].forEach(id => {
          $(id)?.addEventListener('change', () => {
            updateVisibility();
            recalc();
          });
        });
        
        $('plate')?.addEventListener('change', () => {
          setDefaultVolume();
          updateVolLabel();
          updatePlateConstraints();
          
          // Clear invalid values when plate changes
          const plate = $('plate')?.value || '96';
          const plateNum = parseInt(plate);
          const [maxRows, maxCols] = PLATE_GEOM[plate];
          
          const numWells = $('numWells');
          if (numWells && parseInt(numWells.value) > plateNum) {
            numWells.value = '';
          }
          
          const numCols = $('numCols');
          if (numCols && parseInt(numCols.value) > maxCols) {
            numCols.value = '';
          }
          
          const numRows = $('numRows');
          if (numRows && parseInt(numRows.value) > maxRows) {
            numRows.value = '';
          }
          
          recalc();
        });
        
        // Million cells button: multiply the entered stock concentration by 10^6 for convenience
        $('millionBtn')?.addEventListener('click', () => {
          const input = $('knownStockConc');
          if (!input) return;
          const current = parseFloat(input.value) || 0;
          // Multiply by one million and update the field. Do not change step.
          input.value = (current * 1000000).toString();
          recalc();
        });
        
        // Enforce constraints on input
        $('numWells')?.addEventListener('input', (e) => {
          const plate = $('plate')?.value || '96';
          const max = parseInt(plate);
          if (parseInt(e.target.value) > max) {
            e.target.value = max;
          }
        });
        
        $('numCols')?.addEventListener('input', (e) => {
          const plate = $('plate')?.value || '96';
          const [_, maxCols] = PLATE_GEOM[plate];
          if (parseInt(e.target.value) > maxCols) {
            e.target.value = maxCols;
          }
        });
        
        $('numRows')?.addEventListener('input', (e) => {
          const plate = $('plate')?.value || '96';
          const [maxRows, _] = PLATE_GEOM[plate];
          if (parseInt(e.target.value) > maxRows) {
            e.target.value = maxRows;
          }
        });
        
        document.querySelectorAll('input, select').forEach(el => {
          el.addEventListener('input', () => {
            if (el.id === 'cellsPerVial' || el.id === 'volPerVialMl') {
              updateFreezingFieldLocking();
            }
            recalc();
            saveState();
          });
        });
        
        $('saveCountBtn')?.addEventListener('click', saveCount);
        $('downloadCsvBtn')?.addEventListener('click', downloadExcel);
        $('resetSessionBtn')?.addEventListener('click', () => {
          localStorage.removeItem(STORAGE_KEY);
          location.reload();
        });

        // Update filename preview when experiment name changes
        $('experimentName')?.addEventListener('input', updateFilenamePreview);

        // Initial setup
        updateVisibility();
        setDefaultVolume();
        updatePlateConstraints();
        updateFreezingFieldLocking();
        updateExperimentNameDate();
        updateFilenamePreview();
        recalc();

        // Update experiment name date at midnight (check every minute)
        setInterval(() => {
          updateExperimentNameDate();
        }, 60000);
      }

      // Start
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', init);
      } else {
        init();
      }
    })();
  </script>
</body>
</html>
